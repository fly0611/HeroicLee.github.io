<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[02.Centos安装Python3及设置对应版本pip]]></title>
    <url>%2F02.Centos%E5%AE%89%E8%A3%85Python3%E5%8F%8A%E8%AE%BE%E7%BD%AE%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%ACpip%2F</url>
    <content type="text"><![CDATA[安装Python3 安装Python依赖： yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 由于Python在linux不支持我们以可执行程序的方式安装，所以需要我们选择对应的版本源码安装源码下载站点： https://www.python.org/ftp/python/ 以Python3.6为例： wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgztar -zxvf Python-3.6.2.tgzcd Python-3.6.2/ 创建Python安装路径： sudo mkdir /usr/local/python3 指定安装路径： ./configure –prefix=/usr/local/python3 执行安装命令： sudo make &amp;&amp; sudo make install 将安装目录下的Python设置软连接 sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3 注意：在这里的Python3目录下，其实和我们Windows安装好Python的目录类似，bin目录类似win下Python的Scripts目录，其中包含了Python的很多组件和你将要安装的三方模块 为Python3设置PIP 由于源码安装的过程中，Python3其中已经是默认安装了pip及setuptools，所以只需要我们为其设置Linux的环境变量，创建软件连到 /usr/bin/ 下即可 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 由于python2被我们的系统所使用，所以这里保守的办法是Python3的东西都起名叫做xx3当然你也可以修改默认的系统使用Python2地址的导入信息，来使Python3成为默认python环境。 为Python2设置PIP 在linux下，现在已经是默认自带了Python2但是可能部分系统类型还没有pip这个工具，那么需要我们额外的手动安装 安装扩展源： yum -y install epel-release 使用yum安装 yum install python-pip]]></content>
      <categories>
        <category>0、Python环境部署</category>
      </categories>
      <tags>
        <tag>Python环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Python你可能需要的]]></title>
    <url>%2F01.%E5%AD%A6%E4%B9%A0Python%E4%BD%A0%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E7%9A%84%2F</url>
    <content type="text"><![CDATA[安装的Python这里还是建议大家多用python3吧，python2已经被官方明确了时间，之后将不会再有官方支持的更新和迭代 包含Win及Linux环境的安装包地址： 链接：https://pan.baidu.com/s/1bpNUkn9 密码：tts4 你也可以去官方网址选择对应系统进行下载： 官方地址：https://www.python.org/ 编辑器推荐编辑器：（以下仅作建议，不做要求，看个人喜好选择你使用的编辑器) Atom Sublime SublimeSublime很好，轻量级，不光可以写Python，还可以写C，C++很多语言 AtomAtom编辑器是github历时多年鼓捣而出，是一款非常舒服的编辑器一般在linux下面写代码，可以使用这款编辑器的sftp插件，直接在远程主机同步代码，而不需要额外进行代码移植或vim原生态编写(我是觉得vim用起来不如编辑器爽) 推荐安装插件： sftp Chinese 下载地址： 链接：https://pan.baidu.com/s/1dGCBaP7 密码：ektp Linux镜像地址推荐使用centos7，文件系统，内核等都做了更好的支持 下载地址：链接：https://pan.baidu.com/s/1c367zPm 密码：uf8k 一些与linux交互的软件这些软件可以让我们在远程很方便的操作Linux，进行一些命令的提交，文件的传输等等(行话叫ssh,ftp)还包括一些可视化数据库管理软件 下载地址： 链接：https://pan.baidu.com/s/1jJVxFLW 密码：ry1b]]></content>
      <categories>
        <category>0、Python环境部署</category>
      </categories>
      <tags>
        <tag>Python环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pickle模块]]></title>
    <url>%2FC4.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-pickle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[pickle模块函数pickle模块可以很方便的将Python数据对象转换为二进制，并且保存原有数据状态 数据对象二进制保存在内存 pick_obj = pickle.dumps(obj)：将Python数据对象经过pickle处理，返回二进制数据 obj= loads(pick_obj)：将pickle二进制数据转换为Python数据对象 1234567&gt;&gt;&gt; import pickle&gt;&gt;&gt; obj = [1,2,3]&gt;&gt;&gt; p_obj = pickle.dumps(obj)&gt;&gt;&gt; p_objb'\x80\x03]q\x00(K\x01K\x02K\x03e.'&gt;&gt;&gt; type(p_obj)&lt;class 'bytes'&gt; 1234567&gt;&gt;&gt; p_objb'\x80\x03]q\x00(K\x01K\x02K\x03e.'&gt;&gt;&gt; re_obj = pickle.loads(p_obj)&gt;&gt;&gt; re_obj[1, 2, 3]&gt;&gt;&gt; type(re_obj)&lt;class 'list'&gt; 数据对象二进制保存到文件 dump(object,file)：将对象写到文件，这个文件可以是实际的物理文件，但也可以是任何类似于文件的对象 obj = load(file)：把文件对象里的我们之前保存进来的二进制数据返回成原先的数据对象 123456789import picklelist1 = [1,2,3,4,'abc',(1,2,3)]fp = open('1.pkl','wb') #这里我们用到了二进制写文件pickle.dump(list1,fp) #序列化之后保存到文件里fp.close()fp = open('1.pkl','rb') #以二进制读写文件打开文件list2 = pickle.load(fp) #我们从文件里读取我们之前存储的内容print(list2) 12C:\Users\Administrator\Desktop&gt;python 1.py[1, 2, 3, 4, &apos;abc&apos;, (1, 2, 3)] 1.pkl文件内容： 1238003 5d71 0028 4b01 4b02 4b03 4b04 58030000 0061 6263 7101 4b01 4b02 4b03 87710265 2e 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2FC3.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常介绍当我们的程序发生一些解释器无法继续处理下去的事情，我们的解释器无法执行无法编译，这时会抛出错误(异常)一般的异常是一些逻辑错误，语法错误，无法生成结果等抛出错误(异常)之后，我们的程序将无法正常执行下去(抛出的错误会使我们的程序(一般是终止)做错误的默认处理)但是我们也可以自己去改写出现错误之后的默认处理动作，也叫做捕获异常；这么做的目的就是为了提高我们程序的健壮性，应对各种复杂的互联网计算机环境 一些常见的异常 尝试访问未声明变量： 1234&gt;&gt;&gt; aTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'a' is not defined 除数为0： 1234&gt;&gt;&gt; 1/0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: integer division or modulo by zero 语法错误： 12345&gt;&gt;&gt; if File "&lt;stdin&gt;", line 1 if ^SyntaxError: invalid syntax 访问字典中不存在的key值： 12345&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict[3]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 3 索引超出范围： 12345&gt;&gt;&gt; mylist = [1,2,3,4,5]&gt;&gt;&gt; mylist[5]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range 访问未知的对象属性： 12345&gt;&gt;&gt; mylist = [1,2,3,4,5]&gt;&gt;&gt; mylist[5]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range 缩进错误： 1234567&gt;&gt;&gt; a = 1&gt;&gt;&gt; if a == 1:... print 'a==1' File "&lt;stdin&gt;", line 2 print 'a==1' ^IndentationError: expected an indented block 异常捕获将可能发生错误的语句写到try语句部分使用except语句捕获对应异常如果不明确捕捉的异常，可使用Exception将所有异常列为被捕捉对象 语法格式： 1234try: 语句except 异常: 捕获异常后的执行语句 12345678&gt;&gt;&gt; def func():... print(1 / 0)...&gt;&gt;&gt; func()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in funcZeroDivisionError: division by zero 123456&gt;&gt;&gt; try:... func()... except ZeroDivisionError:... print('除数为0')...除数为0 try…finally 语法格式： 123456try: 语句except Exception: 捕获异常后的执行语句finally: 不管异常抛出，都将执行这里的语句 1234567891011&gt;&gt;&gt; def func():... print(1 / 0)...&gt;&gt;&gt; try:... func()... except Exception:... print('出错了')... finally:... print('finally')...出错了 try…else 我们一般在else语句中执行关闭套接字，关闭文件句柄，线程，进程资源释放，做一些对象内存释放的工作为什么不在finally中呢？这是因为可能因为异常抛出，我们对应的资源句柄连创建都没有完成，也就没有必要对应的释放 123456try: 语句except Exception: 捕获异常后的执行语句else: 这里语句只在没有异常触发时执行 12345678&gt;&gt;&gt; try:... 1 / 0... except Exception:... print('Error')... else:... print('没有出错')...Error 在异常捕获时，我们一般使用else语句与finally语句配合使用 finally语句被用作最终结束工作，做一些提示或日志写入等而else常用在被捕获语句成功执行后的一些资源释放工作 手动抛出异常 使用raise语句手动抛出异常： 1234&gt;&gt;&gt; raise TypeError('出错了')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 出错了 1234&gt;&gt;&gt; raise TypeErrorTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError 1234&gt;&gt;&gt; raise Exception('出错了')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;Exception: 出错了 手动抛出的异常必须是在当前环境下已注册的；若未定义，则报错 1234&gt;&gt;&gt; raise MyErrorTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'MyError' is not defined 异常也是常用的程序间通信的方式，类似信号 异常也经常用在测试方面：在对某些驱动进行测试时，我们可以在必要情况下手动抛出异常 自定义异常 在Python中所有的异常都是从BaseException这个根异常类派生 这个根异常类派生如下异常类： SystemExit(系统中断) KeyboardIterrupt(ctrl+c) Exception(内建异常类) 我们考虑的所有内建异常都是继承自Exception类我们可以通过继承Exception类，来实现自定义异常 123456789101112131415class Myerror(Exception): passdef checklist(mylist,index): #这个函数输出对应索引位置上的值 print (mylist[index])try: mylist = input('请输入一个序列:') index = int(input('请输入访问位置:')) if index &gt; len(mylist): #如果传入的索引值超过序列最大索引位置 raise Myerror #raise抛出自定义错误except Myerror: #捕获自定义错误 print ('the index is out of range!')else: checklist(mylist,index) 1234C:\Users\Administrator\Desktop&gt;python 1.py请输入一个序列:abc请输入访问位置:4the index is out of range! 断言 断言一般用来判断一些bool语句，在断言成功时不采取任何措施，否则触发AssertionError(断言错误)的异常： 123456&gt;&gt;&gt; assert 1 == 0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AssertionError&gt;&gt;&gt; assert not False&gt;&gt;&gt; #没有抛出断言异常 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Linux下Tree命令]]></title>
    <url>%2FC2.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-%E5%AE%9E%E7%8E%B0Linux%E4%B8%8BTree%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[OS模块及递归实现Tree命令12345678910111213141516171819202122232425262728293031import os#递归遍历一个指定目录下的所有文件和文件夹。def getdir(path,level=0): if path=='': path = os.getcwd()#获取当前的工作目录 level+=4 num = level // 4 abs_path = os.path.abspath(path) for name in os.listdir(path):#返回的是一个列表 format_str = '' if os.path.isfile(os.path.join(abs_path,name)): for var in range(num):#range函数用来控制循环次数 format_str += '_' * 4 + '▕' format_str = format_str[0:-1] format_str += name mystr = format_str.replace('_',' ',level-4)#替换掉level-4个_ else: for var in range(num):#range函数用来控制循环次数 format_str += '_' * 4 + '▕' #在输出前构造出对应的格式 #我们通过递归的次数来重复输出 ----| format_str += name#----|----|拼接路径 # |____|file # ____|____|____|____|file mystr = format_str.replace('_',' ',level-4)#替换掉level-4个_ print(mystr)#输出格式字符串 name = os.path.join(abs_path,name) if os.path.isdir(name):#绝对路径,判断是否是文件夹 getdir(name,level)path = input('请输入你要遍历的目录：')getdir(path) 看看效果： 思考：如果你已经明白了Tree命令的实现套路，那么试试来实现一下find命令吧！温馨提示：如果你对该段代码难以理解，先别问我；再去好好看看递归，哈哈哈哈哈 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os模块]]></title>
    <url>%2FC1.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-os%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[OS模块 使用os模块时，不需要考虑平台差异，解释器会帮大家选择正确的系统支持可以对进程和进程运行环境进行管理该模块还可以处理大部分文件系统操作，比如删除，重命名文件，遍历目录树，以及管理文件访问权限。 os模块主要有以下几种 : posix (类unix操作系统) nt (win) mac (旧版本的MacOs) dos (DOS)** os和sys： os负责程序与操作系统的交互sys负责程序与解释器的交互 os.path和sys.path： sys.path是PATH环境变量os.path是os模块下的子模块，提供了一些关于路径处理的函数 os模块常用函数 os.name：输出字符串指示正在使用的平台 12&gt;&gt;&gt; os.name'nt' os.getcwd()：得到当前工作目录(就是你的进程所工作的目录)，即当前脚本工作路径 12&gt;&gt;&gt; os.getcwd()&apos;C:\\Users\\Administrator&apos; 运行目录：执行程序时的路径 工作目录：程序运行时，程序中我们要操作其他文件时使用的的一系列相对路径(相对路径需要参照)，工作目录可在程序运行时更改 os.listdir()：返回指定目录下的所有文件和目录名的一个列表，但是并没有列出来什么是目录，什么是文件。 1234&gt;&gt;&gt; os.listdir()&gt;&gt;&gt; os.listdir()[ '桌面', '下载', '模板', '公共', '文档', '音乐', '图片', '视频']#结果为列表，但是并没有列出谁是目录，谁是文件 os.remove(‘file_name’)：删除指定文件，文件不存在则报错 1234&gt;&gt;&gt; os.remove('1.txt')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;FileNotFoundError: [Errno 2] No such file or directory: '1.txt' os.rmdir(‘dir_name’)：删除指定目录 12&gt;&gt;&gt; os.remove('桌面')#删除桌面目录 os.mkdir(‘dir_name’)：创建目录 12&gt;&gt;&gt; os.mkdir('桌面')#创建目录名为桌面 os.makedirs(‘a/b/c’)：递归创建目录 1&gt;&gt;&gt; os.makedirs('a/b/c') os.system(‘ls’)：执行shell命令 12&gt;&gt;&gt; os.system('su rm -rf /*')#四大皆空 os.chdir(‘file_path’)：改变工作目录 12345&gt;&gt;&gt; os.getcwd()'C:\\Users\\Administrator'&gt;&gt;&gt; os.chdir('C:\\Users')&gt;&gt;&gt; os.getcwd()'C:\\Users' os.chmod(‘file_name’)：改变文件或目录的权限 1234&gt;&gt;&gt; os.chmod('1.txt',445)&gt;&gt;&gt; os.system('ls -l 1.txt')-rw-rwxr-x 1 root root 0 1月 19 11:42 1.txt0 Os.path模块常用函数 os.path.abspath(‘file_name’)： 返回文件或目录的绝对路径 不会检查是否存在该文件或目录 12&gt;&gt;&gt; os.path.abspath('1.txt')'/root/1.txt' os.path.split(‘file_path’)： 将路径分隔成目录和文件名，并以一个元组返回 不会检查是否存在该文件或目录 12&gt;&gt;&gt; os.path.split('/root/1.txt')('/root', '1.txt') os.path.basename(‘path’)： 返回路径最后的文件名 如果后面还有\ / 那么返回一个空字符串 不会检查是否存在该文件或目录 12&gt;&gt;&gt; os.path.basename('/root/1.txt')'1.txt' os.path.exists(‘file_path’)： 如果路径存在，则返回True，反之返回False 与上面的函数不同，他就是检查这个路径是否存在 12&gt;&gt;&gt; os.path.exists('/root/2.txt')False os.path.join(‘file_path’，’file_name’)： 路径拼接 不会检查是否存在该文件或目录 1234&gt;&gt;&gt; os.path.join('/root','abc')'/root/abc'&gt;&gt;&gt; os.path.join('root','abc')'root/abc' os.path.isdir(‘name’)： 判断是否为目录，返回值为bool 1234&gt;&gt;&gt; os.path.isdir('/root')True&gt;&gt;&gt; os.path.isdir('1.txt')False os.path.isfile(‘name’)： 判断是否为文件，返回值为bool 1234&gt;&gt;&gt; os.path.isfile('/root')False&gt;&gt;&gt; os.path.isfile('1.txt')True os.path.islink(‘name’)： 判断是否是链接，返回值为bool 12345&gt;&gt;&gt; os.path.islink('1.txt')False&gt;&gt;&gt; os.path.islink('/usr/bin/python3')True#ln -s 是我们在linux下创建连接的命令，类似win下的快捷方式 os.path.getsize(‘path’)： 返回文件大小 如果文件不存在，抛出异常 12345678&gt;&gt;&gt; os.path.getsize('1.txt')0&gt;&gt;&gt; os.path.getsize('2.txt')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/local/python3/lib/python3.6/genericpath.py", line 50, in getsize return os.stat(filename).st_sizeFileNotFoundError: [Errno 2] No such file or directory: '2.txt' 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2FB9.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归 递归的概念：函数包含了对自身的调用，那么就是递归使用的场景：如果你发现你将要做的事情就是你现在做的，那么用递归递归类似循环；在编写或阅读递归时，首先我们关注的是递归的终止条件 递归求和 在接触递归之前，我们先来做这么一个问题：如果说，要对一个数字列表求和（或者其他序列）求和，除了我们可以使用内置的sum函数，还有什么办法？如果你还有更优秀的办法，可以在关于页面找到我的联系方式，有偿提交给我 while循环： 12345L = [1,2,3,4,5]mysum = 0 #保存和的变量while L: #将列表最为循环条件 mysum += L[0] #每次将列表第一个位置的值加到和中 L = L[1：] #去掉列表第一个元素 for循环： 1234L = [1,2,3,4,5]mysum = 0for var in L: mysum += var 递归求和： 1234567def mysum(L): if not L: print ('L is empty') return 0 else: return L[0]+mysum(L[1:]) #在返回值中，我们返回了一个函数的调用，并且传递的参数为去掉当前列表第一个元素的新列表 递归处理非线性循环 递归还可以处理一些非线性循环，而普通的循环是无法处理的比如这样一个列表对其求和： L = [1,[2,[3,4],5],6,[7,8]] 由于这个列表不是一个线性迭代，包含着复杂的元素嵌套普通的循环语句处理起来将会非常难以控制 1234567891011L = [1,[2,[3,4],5],6,[7,8]]sum = 0def mysum(L): global sum for var in L: if not isinstance(var,list): #如果其中元素不为列表类型，则为一个确定的值 sum += var else: mysum(var) return 花钱递归思考：假如你有10000块，每天花一半，毛钱直接舍弃，那么这钱可以花几天？ 递归解决： 12345678def cost(money,day=0): if money &gt; 0: money = money // 2 #每次花一半 day += 1 #花完天数+1 cost(money,day) #开启花钱递归 else: print('一共可以花%d天' % day) return #必须要有的一个终止条件 递归注意事项 递归的最大上限次数取决于当前操作系统的内存一个没有终止条件的递归会引发错误(类似一个死循环)这是因为递归的每一次函数执行*，都会在内存中产生新的函数副本，递归的内存消耗要大于普通循环；但是同样的，消耗了内存，效率高**于普通循环 123456789101112&gt;&gt;&gt; def func():... return func()...&gt;&gt;&gt; func()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in func File "&lt;stdin&gt;", line 2, in func File "&lt;stdin&gt;", line 2, in func [Previous line repeated 995 more times]RecursionError: maximum recursion depth exceeded#这里我们在995次递归之后，达到上线，从而报错 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数]]></title>
    <url>%2FB8.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[匿名函数 匿名函数(lambda表达式)： 除了def语句之外，我们还可以使用lambda表达式创建函数 这样创建出来的函数，需要额外使用变量名保存 匿名函数一般用来创建简单函数，或制作跳转表 语法格式： lambda 参数1，参数2，参数3，参数N：表达式 123&gt;&gt;&gt; f = lambda x,y : x+y&gt;&gt;&gt; f(1,2)3 缺省参数也可以在lambda中使用注意缺省参数定义顺序 123456&gt;&gt;&gt; f = lambda x,y=1 : x+y&gt;&gt;&gt; f(10)11&gt;&gt;&gt; f = lambda x=1,y : x+y #缺省参数定义顺序一定是从右向左 File "&lt;stdin&gt;", line 1SyntaxError: non-default argument follows default argument 跳转表 跳转表 (jump table)：函数方法的列表或字典，能够按照需要执行相应的动作 123L = [ lambda x:x*2 , lambda x:x*3 , lambda x:x*4] #含有三个lambda函数的列表for f in L: print(f(2)) 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数嵌套需要注意的地方]]></title>
    <url>%2FB7.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[函数嵌套 内部函数整个函数体都在外部函数的作用域如果在外部没有对这个函数的引用，那么除了在函数体内，任何地方都不能调用这个函数 1234def func1(): print('1') def func2(): print('2') 如果我们想使用函数内部定义的func2()，可以采用前项声明的方式 1234567def func2(): passdef func1(): print('1') global func #声明局部函数为全局函数对象 def func2(): print('2') 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数作用域]]></title>
    <url>%2FB6.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[函数作用域本地全局1234a = 1def add(y,z): print y+z+a return y+z+a 全局变量名：a add 因为这个a是在这个文件内最外层注册的变量名，所以他是全局变量 全局变量能够在函数内部直接使用，而不需要特定的声明 全局变量的生命周期：在整个程序运行期间。 本地变量名：y,z y和z的注册地址在函数内部，y和z是局部变量 局部变量生命周期：函数运行期间 1234567891011&gt;&gt;&gt; a = 1&gt;&gt;&gt; def change():... a = 2... print(a)...&gt;&gt;&gt; a1&gt;&gt;&gt; change() #打印函数内部修改之后的a2&gt;&gt;&gt; a #打印外部a1 外部的a并没有被修改 这是因为，函数内部赋值的变量除非声明为全局变量或非本地变量，否则均为本地变量 这里的a = 2，因为是在函数内部使用赋值的，所以解释器会把它当作一个函数内部的变量，他的作用域是这个函数内部 如果想修改一个全局变量，只需要在函数内部被修改变量前加global语句 123456789101112&gt;&gt;&gt; a = 1&gt;&gt;&gt; def change():... global a... a = 2... print(a)...&gt;&gt;&gt; a1&gt;&gt;&gt; change() #打印函数内部修改之后结果2&gt;&gt;&gt; a #打印外部的a值2 函数传参需要注意的地方 函数传参： 可变对象作为参数传递，可以在函数内部直接修改初始数据对象的值，是传引用 不可变对象传递时，无法直接修改初始数据对象的值，是传值 传递一个不可变对象，按值传递： 123456789&gt;&gt;&gt; a = 1&gt;&gt;&gt; def change(a):... a = 2... print(a)...&gt;&gt;&gt; change(a)2&gt;&gt;&gt; a1 传递一个可变对象，按引用传递： 123456789101112&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; def change(a):... a[0] = 'a'... print(a)...&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; change(a)['a', 2, 3]&gt;&gt;&gt; a['a', 2, 3]#可变对象作为参数传递，传的是引用，内部修改影响全局 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数的构成]]></title>
    <url>%2FB5.Python%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[函数的构成当我们在编程过程中，发现某些功能可能会一直在我们的整个程序中使用，那么这里就需要函数来实现对功能的包装 def语句 def语句可以在运行时，创建一个新的函数对象并赋值给一个变量名 def语句可以出现在一个Python脚本任何地方 def语句定义函数可以嵌套，甚至是在if语句中 12345&gt;&gt;&gt; def func():... print('hello world')... &gt;&gt;&gt; func()hello world 参数参数是我们在定义一个函数时，可能需要在函数内部处理一些外界的变量，那么需要通过参数来进行数据的导入 123456&gt;&gt;&gt; def func(a,b):... return a + b... &gt;&gt;&gt; var = func(1,2)&gt;&gt;&gt; var3 形参: 定义函数时后面括号里所写的形式参数，如这里的a, b，也称形参 可理解为占位意义 实参: 在函数实际调用时，如这里的1, 2传入的数据为实参，也称实际参数 必备参数 定义函数时的形参，在我们传递实参时，需要数量和顺序保持一致 1234567891011121314&gt;&gt;&gt; def func(age,sex):... print('bob age is %d, sex is %s ' % (age, sex))...&gt;&gt;&gt; func(10,'male') #按照规矩来bob age is 10, sex is male&gt;&gt;&gt; func('男性',20) #不按规矩来，第一个位置的值被填写到了print时的%d处，引发错误Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in funcTypeError: %d format: a number is required, not str&gt;&gt;&gt; func(10) #少传了一个参数，也会引发异常Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: func() missing 1 required positional argument: 'sex' 命令参数 我们可以通过命名传参的方式，打乱传递参数的顺序 12345&gt;&gt;&gt; def func(age,sex):... print('bob age is %d, sex is %s ' % (age, sex))... &gt;&gt;&gt; func(sex='女人',age=18)bob's age is 18, sex is 女人 缺省参数 某些情况下，可能我们的函数会经常处理一些相同的数据，那么可以通过在形参中定义缺省参数的方式来实现 缺省参数一定是从右向左的顺序来设置 因为实参默认的接收顺序为从左向右，如果缺省参数之后还有一个需要传递值的形参，那么可能因为缺省参数已经被覆盖了值，而导致后面位置的形参无法接收到实际值而报错 12345&gt;&gt;&gt; def func(today,wea='Sunny'):... print('today is %s, weather is %s.' % (today,wea))...&gt;&gt;&gt; func('礼拜一')today is 礼拜一, weather is Sunny. 不定长参数 某些时候我们需要传入的实参可能无法在形参处确定，那么可以使用不定长传参的方式 arg：接收不定长参数为*元组形式 1234567&gt;&gt;&gt; def func(*arg):... print(type(arg))... print(arg)...&gt;&gt;&gt; func(1,2,3,4,5) #传入不定长实参&lt;class 'tuple'&gt; # *arg接收不定长实参会被保存为元组类型(1, 2, 3, 4, 5) **arg：接收不定长参数为键值对形式(字典) 1234567891011&gt;&gt;&gt; def func(**arg):... print(type(arg))... print(arg)...&gt;&gt;&gt; func(a=1,b=2,c=3)&lt;class 'dict'&gt; # **arg 接收不定长键值对形式实参会被保存为字典类型&#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; func(1,2,3) # **arg 格式接收不是键值对形式的参数，将会爆出TypeErrorTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: func() takes 0 positional arguments but 3 were given 返回值 return语句： 可以返回任意类型的对象作为返回值(包括函数，对象实例等) 同时也可以返回多个值，在返回多个值时，会处理为一个元组 返回的值可以通过函数调用之后使用等号(=)赋值给一个变量 123456&gt;&gt;&gt; def func():... return 1,2...&gt;&gt;&gt; var = func()&gt;&gt;&gt; var(1, 2) 转载请注明原文地址]]></content>
      <categories>
        <category>2、Python函数基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推导式]]></title>
    <url>%2FB4.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8E%A8%E5%AF%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[推导式推导式是一种可以更加方便生产某种数据的方式比如生产一些具有一定要求的列表，元组，字典等数据集 列表推导式语法格式： [ 表达式 for value in 序列 if 过滤条件 ] 解释： 所有从这个for循环出来的数据 首先会经过if条件过滤 执行表达式计算 重新返回成一个新的列表，过滤条件按照需求也可以没有 12345678&gt;&gt;&gt; mylist = [1,2,3,4,5]&gt;&gt;&gt; newlist = [ var + 1 for var in mylist ]&gt;&gt;&gt; newlist[2, 3, 4, 5, 6]&gt;&gt;&gt; mylist = [1,2,3,4,5]&gt;&gt;&gt; newlist = [ var * var for var in mylist if var != 3]&gt;&gt;&gt; newlist[1, 4, 16, 25] 字典推导式字典推导式：与列表推导式类似，只不过需要两个值存在来维护字典的键值对形式 语法格式： { key:value for key in 序列 if 过滤条件 } 1234&gt;&gt;&gt; mylist = ['a','b','c']&gt;&gt;&gt; new_dict = &#123;mylist.index(var):var for var in mylist&#125;&gt;&gt;&gt; new_dict&#123;0: 'a', 1: 'b', 2: 'c'&#125; 思考：如何将字典中的员工工资通过字典推导式分别加100呢？ {‘jack’:{‘money’:1000},’bob’:{‘money’:1000}} 好记性不如烂笔头好记性不如烂笔头好记性不如烂笔头，你觉得呢 集合推导式集合推导式跟列表推导式非常相似，唯一语法区别在于用 { } 代替 [ ]： 语法格式： { 表达式 for value in 序列 if 过滤条件 } 12345&gt;&gt;&gt; mylist['a', 'b', 'c']&gt;&gt;&gt; myset = &#123; var.upper() for var in mylist&#125;&gt;&gt;&gt; myset&#123;'C', 'B', 'A'&#125; 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSV文件操作]]></title>
    <url>%2FB3.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-CSV%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[CSV文件 CSV简介： CSV文件通常用于我们在电子表格软件和纯文本之间交互数据，CSV文件内容是一些用逗号分隔的原始字符串。 CSV文件的操作在Python中有单独的模块来使用，模块名为csv CSV文本操作 导入模块：import csv 打开文件对象：fp = open(‘1.csv’, ‘a+’ ) 返回专门用做csv处理的读，或写对象：fp = csv.writer(fp)；fp = csv.reader(fp) CSV写文件csv提供了一个写函数：writerow()方法，为文件写入以逗号分割的数据逗号分割的数据：常见的有list，tuple，set 12writer = csv.writer(fp)writer.writerow(('a','b','c','d')) 注意：在写csv文件的时候，可能会出现一行数据一个空行可以通过在打开文件时指定: newline=’’ 或以二进制打开: open(‘data.csv’,’wb’) open(‘data.csv’,’w’,newline=’’)csvfile = open(‘data.csv’,’w’) CSV读文件123reader = csv.reader(fp) #生成对应文件的csv读对象for var1,var2,var3… in reader: print(var1,var2,var3…) 我已经写出了套路，如果你自己不动手，只能看到这些！！！ 字典形式读写文件除了以上读写csv文件的方式，csv模块还提供了 csv.DictReader() 和 csv.DictWriter()用于将字典形式的数据写入csv文件，以及从csv文件读取出的数据保存在字典中 1234567891011121314151617import csv#csv.DictWriterwith open('names.csv', 'w') as csvfile: fieldnames = ['first_name', 'last_name']#指定标题列 writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() writer.writerow(&#123;'first_name': 'Baked', 'last_name': 'Beans'&#125;) writer.writerow(&#123;'first_name': 'Lovely', 'last_name': 'Spam'&#125;) writer.writerow(&#123;'first_name': 'Wonderful', 'last_name': 'Spam'&#125;)#csv.DictReaderwith open('names.csv') as csvfile: reader = csv.DictReader(csvfile) for row in reader: print(row['first_name'], row['last_name'])#根据标题列定义的数据取行内容 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
        <tag>Python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作实现验证系统]]></title>
    <url>%2FB2.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件操作实现验证系统在某些情况下，文件是一个非常棒的数据库系统；我们在使用文件作为数据库使用时，可以使效率更高更快并且使用文件系统作为数据库，可以在我们应对一些轻量级难题时，节省开发成本 在文件作为数据库时，我们需要把数据的保存格式进行设计用户名密码以 account:passwd\n 形式保存在文件中(注意行末有换行) 用户注册1234567891011121314151617181920212223242526272829myfile = open('user.txt','a+')#使用a+权限打开文件，避免将之前的内容所覆盖。a = 1#判断是否已经注册的标志位while True: account = input('请输入你要注册的帐号:') myfile.seek(0,0)#注册帐号之前，首先要确定该帐号没有被注册过。 for buf in myfile: account_buf = buf.split(':')[0] #我们依次会读取出文件中的每一行数据，按照我们的格式把帐号取出来 if account_buf == account: print('已经被注册，请重新输入:') a = 0 break #跳出循环 #读到最后一行也没有相等，那么说明我们文件中没有这个用户，继续向下，注册密码 #注意，到了这里，文件读写指针通过for循环已经到了末尾。所以不必担心继续写入内容导致覆盖掉之前的 if a == 1: passwd1 = input('请输入你要注册的密码:') passwd2 = input('请再次输入你要注册的密码:') if passwd2 == passwd1:#两次密码校验 str = '%s:%s\n'%(account,passwd1)#文件中写入帐号密码 myfile.write(str) print('注册成功') break else: print('密码不相同，请再次输入') continue else: breakmyfile.close()#关闭文件 效果如图： 用户登陆12345678910111213141516171819202122232425myfile = open('user.txt','r')#登录时候，只需要读取权限logintimes = 0islogin = 1 #该变量等于1的情况下你是没有登录的。while True: if islogin == 1:#重试登陆次数最大为3 if logintimes == 3: print('登录超过次数，再见') break#跳出主循环 else: print('这是你第%d次登录，你还剩余%d次机会。'%(logintimes,3-logintimes)) account = input('请输入你的帐号：') passwd = input('请输入你的密码：') myfile.seek(0,0)#为了避免因为重复登录而我们的文件描述符已经到了后面，导致之前的无法判断 for buf in myfile: account_buf = buf.split(':')[0] passwd_buf = buf.split(':')[1][:-1]#去掉行尾的换行符，同样可以使用str.strip if account_buf == account and passwd == passwd_buf: print('登录成功:',account_buf) islogin = 0#登录成功则修改标志位 break #但是这里的break只能跳出最内圈循环，想要结束全部，我们可以设置一个标记位；用来确定我们是否已经登录 logintimes += 1 continue else: break 效果如图： 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
        <tag>Python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2FB1.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作 打开文件 读写文件 打开文件 fp = open(path,mode=’r’)：该函数可以路径为Path的文件，默认以读权限打开，并返回一个打开文件对象 打开权限 r：读 w：写 a：追加 单纯使用这三种方式打开文件，只拥有一种打开权限，要么读，要么写 如果希望在打开文件的时候，读写权限兼备，那么可以在权限后带一个+号 r+：读写 不创建新文件 文件读写指针在开头 w+：读写 创建新文件 读写指针在开头 如果文件存在则会清空这个文件之前的内容 a+：读写 创建新文件 读写指针在末尾 不会清空该文件之前的内容 含有写权限在打开一个不存在文件时，该文件将被创建 关闭文件 fp.close()：该函数可以关闭文件对象，并且刷新缓冲区 读文件 str = read(num)：读取文件放到字符串变量中，参数num为指定读取的字符数，默认为全读 1.txt文件其中内容：aaabbb 12345&gt;&gt;&gt; fp = open('1.txt','r+')&gt;&gt;&gt; mystr = fp.read(2)&gt;&gt;&gt; print(mystr)aa&gt;&gt;&gt; fp.close() str = readline()：读取一行到一个字符串变量中(读到换行符(\r\n)，包括行末的标识符，或者是文件结束的标识(EOF) ) 1234567&gt;&gt;&gt; fp = open('1.txt','r+')&gt;&gt;&gt; mystr = fp.readline()&gt;&gt;&gt; print(mystr)aaa&gt;&gt;&gt; fp.close()#输出的多余空行为文件中一行结尾的换行符 str_list = readlines(size)：读取整个文件到字符串列表。 12345&gt;&gt;&gt; fp = open('1.txt','r+')&gt;&gt;&gt; str_list = fp.readlines()&gt;&gt;&gt; print(str_list)['aaa\n','bbb']&gt;&gt;&gt; fp.close() 每次调用 readlines(size) 函数，会返回大约200MB的数据，而且所返回的必然都是完整的行数据，大多数情况下，返回的数据的字节数会稍微比 size 指定的值大一点（除最后一次调用readlines(size) 函数的时候）。通常情况下，解释器会自动将用户指定的 size的值调整成内部缓存大小的整数倍 写文件 write(‘str’)：在文件中写入字符串 file.writelines(list_of_string) ：把字符串列表写入文件 1234&gt;&gt;&gt; fp = open('1.txt','w')&gt;&gt;&gt; fp.write('abc\n')&gt;&gt;&gt; fp.writelines(['bbb\n','ccc\n']) #写入字符串列表&gt;&gt;&gt; fp.close() 写入文件字符串的方法不会自动的加上换行符，所以需要大家在写入时，手动写入换行符标志\n写入文件的内容我们并不能直接在磁盘文件看到，这是因为写入的内容暂时被保存在了缓存中；我们可以通过使用 fp.close()或fp.flush()函数来进行缓冲区刷新操作，使写入文件的内容直接保存在磁盘中 刷新缓冲区 fp.close() fp.flush() 读写指针每次读或写操作之后我们会发现，我们下次的都操作都是在这一次之后，这是因为我们在打开一个文件的同时，内存中会维护一个读写指针用来标识我们访问文件的位置，一个文件对象读写操作共享同一根指针 1.txt文件其中内容：aaabbb 123456&gt;&gt;&gt; fp = open('1.txt','r')&gt;&gt;&gt; fp.readline()aaa\n&gt;&gt;&gt; fp.readline()bbb\n#这里第二次读操作继续在第一次操作之后 修改读写指针位置 file.seek(offset[,whence])：修改访问文件位置 offset：偏移量 whence： 从何处偏移；0 从文件开头， 1 从当前位置， 2 从文件末尾处 注意：以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾，如果此时你想读文件开头部分内容，需要修改读写指针位置为fp.seek(0, 0) 关于文件操作我们会在下一节有更加详细的代码进行练习说明 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
        <tag>Python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用内建函数]]></title>
    <url>%2FA9.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[字符串内建函数在字符串类型中，还包含一些其他方便我们处理数据的内建函数，注意：某些函数可能返回结果与原字符串不同，但并不是修改了本身字符串，只是返回了一个新的而已 大小写转换函数 string.lower()：字母大写转换为小写 123&gt;&gt;&gt; mystr = 'aBc,bDc'&gt;&gt;&gt; mystr.lower()'abc,bdc' string.upper()：字母小写转换成大写 123&gt;&gt;&gt; mystr = 'aBc,bDc'&gt;&gt;&gt; mystr.upper()'ABC,BDC' string.swapcase()：字母大写转换小写，小写转换成大写 123&gt;&gt;&gt; mystr = 'aBc,bDc'&gt;&gt;&gt; mystr.swapcase()'AbC,BdC' string.title()：将每个单词首字母大写，将句中字符变为小写 123&gt;&gt;&gt; mystr = 'aBc,bDc'&gt;&gt;&gt; mystr.title()'Abc,Bdc' string.capitalize()：将第一个字母大写，将句中字符变为小写 123&gt;&gt;&gt; mystr = 'aBc,bDc'&gt;&gt;&gt; mystr.capitalize()'Abc,bdc' 搜索函数 string.find(str,[start=0,stop=len(string)])：计算string中出现str的第一个字母的索引，如果没有出现，则返回-1 12345&gt;&gt;&gt; mystr = 'aabbcc'&gt;&gt;&gt; mystr.find('a')0&gt;&gt;&gt; mystr.find('1')-1 string.index(str ,[start=0,stop=len(string)])：计算string中出现str的第一个字母的索引，如果没有出现，引发异常 1234567&gt;&gt;&gt; mystr = 'aabbcc'&gt;&gt;&gt; mystr.index('b')2&gt;&gt;&gt; mystr.index('d')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found string.count(str ,[start=0,stop=len(string)])：计算str在string中出现的次数 12345&gt;&gt;&gt; mystr = 'aabbcc'&gt;&gt;&gt; mystr.count('a')2&gt;&gt;&gt; mystr.count('d')0 string.endswith(chr,[start=0,stop=len(string)])：检查string是否以chr结尾，如果是，返回True，反之，返回False 12345&gt;&gt;&gt; mystr = 'aabbcc'&gt;&gt;&gt; mystr.endswith('cc')True&gt;&gt;&gt; mystr.endswith('aa')False 替换函数 string.replace(str1, str2,[num= string.count(str1)])：将str1替换为str2, num为替换次数，默认次数为str1出现的次数 123456&gt;&gt;&gt; mystr = 'aabbcc'&gt;&gt;&gt; mystr.replace('a','*')'**bbcc'&gt;&gt;&gt; mystr = 'aabbcc'&gt;&gt;&gt; mystr.replace('a','*',1)'*abbcc' string.strip(chr)：在string的开头和结尾删除chr，当chr为空时，默认删除空白符 123456&gt;&gt;&gt; mystr = ' aabbcc '&gt;&gt;&gt; mystr.strip()'aabbcc'&gt;&gt;&gt; mystr = '**abc**'&gt;&gt;&gt; mystr.strip('*')'abc' string.rstrip(chr)：删除string字符串末尾的空白符或给定字符 123&gt;&gt;&gt; mystr = ' aabbcc '&gt;&gt;&gt; mystr.rstrip()' aabbcc' 分割，组合函数 string.split(chr,num=string.count(str))：以chr为分割符将string字符串分割，返回分割后的结果保存在列表中；如果指定num参数，则只分割前num次 123&gt;&gt;&gt; mystr = 'a:b:c'&gt;&gt;&gt; mystr.split(':')['a', 'b', 'c'] chr.join(str.[list,tuple])：以chr作为连接符，拼接字符串序列 1234&gt;&gt;&gt; ''.join(['a','b','c'])'abc'&gt;&gt;&gt; '*'.join(['a','b','c'])'a*b*c' 判断函数 string.isdigit()：如果string只包含数字，则返回True，否则返回False 123&gt;&gt;&gt; mystr = '123'&gt;&gt;&gt; mystr.isdigit()True string.islower()：字符串中的字母全为小写则返回True，否则返回False 123&gt;&gt;&gt; mystr = 'abc'&gt;&gt;&gt; mystr.islower()True string.isupper()：字符串中的字母全为大写则返回True，否则返回False 123&gt;&gt;&gt; mystr = 'ABC'&gt;&gt;&gt; mystr.isupper()True string.isspace()：字符串中只包含空白字符，返回True，否则返回False 123&gt;&gt;&gt; mystr = ' '&gt;&gt;&gt; mystr.isspace()True 列表内建函数 list.append(obj)：在列表尾部追加obj 1234&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist.append('abc')&gt;&gt;&gt; mylist[1, 2, 3, 'abc'] list.count()：返回一个对象在列表中出现的次数 123&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist.count(1)1 list.extend(seq)：把序列seq中的内容分别提取并加入到列表中 1234&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist.extend('abc')&gt;&gt;&gt; mylist[1, 2, 3, 'a', 'b', 'c'] list.insert(index,obj)：在索引index的位置插入obj，原位置的内容向后移动 1234&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist.insert(1,'a')&gt;&gt;&gt; mylist[1, 'a', 2, 3] list.pop(index)：删除并返回index位置的数据对象，默认是最后一个对象 12345&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist.pop()3&gt;&gt;&gt; mylist[1, 2] list.reverse()：反转列表 1234&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist.reverse()&gt;&gt;&gt; mylist[3, 2, 1] 元组内建函数 tuple.index(obj,beg=0,end=len(string))：检查obj是否包含在tuple中，不存在会报错 1234567&gt;&gt;&gt; mytuple = (1,2,3)&gt;&gt;&gt; mytuple.index('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: tuple.index(x): x not in tuple&gt;&gt;&gt; mytuple.index(1)0 tuple.count(obj)：返回obj在元组中出现的次数 123&gt;&gt;&gt; mytuple = (1,2,3)&gt;&gt;&gt; mytuple.count(1)1 系统内建函数 reversed(seq)：接受一个序列作为参数，返回一个以逆序访问的迭代器 1234567&gt;&gt;&gt; mytuple = (1,2,3)&gt;&gt;&gt; for var in reversed(mytuple):... print(var)...321 sorted(iter,key=None,reverse=False)：接受一个可迭代对象作为参数，返回一个有序的列表，可选参数是一个排序方式 123456789&gt;&gt;&gt; mytuple = (3,5,7,2,9)&gt;&gt;&gt; sorted(mytuple)[2, 3, 5, 7, 9]&gt;&gt;&gt; mylist = ['aa','bbb','c']&gt;&gt;&gt; def cmp(x):... return len(x)...&gt;&gt;&gt; sorted(mylist,key=cmp)['c', 'aa', 'bbb'] sum(seq,init=0)：返回seq的总和 123&gt;&gt;&gt; mylist = [1,2,3,4,5]&gt;&gt;&gt; sum(mylist)15 zip(it0,it1,..itN)：返回一个zip数据类型，将其中序列相同位置的值组成一个元组，以短板结束 12345678&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = ['a','b','c','d']&gt;&gt;&gt; for var in zip(a,b):... print(var)...(1, 'a')(2, 'b')(3, 'c') map(func,seq)：map函数第一个参数可以是一个函数对象，第二个是一个序列，函数将作用于序列中的每个值，返回一个map数据类型 12345678910&gt;&gt;&gt; def func(x):... return x*x...&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; for var in map(func,mylist):... print(var)...149 reduce(func,seq)：该函数来自于functools标准库，把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，他会把结果继续和序列的下一个元素做累积计算 1234567&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def myadd(x,y):... return x+y...&gt;&gt;&gt; mylist = [1,2,3,4,5]&gt;&gt;&gt; reduce(myadd,mylist)15 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典集合数据类型]]></title>
    <url>%2FA8.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[字典 字典以键值对形式存在：{ key: value } 其中key值会进行hash运算，生成hash表，所以字典的访问效率要优于普通序列数据类型(列表，元组) key值由于需要通过hash，则一些可变数据类型不可以做key值，而value的类型没有限制，可以是任意数据类型 由于进行了hash运算，那么在内存中字典其中的数据元素是无序的，没有办法进行一些像索引和切片一样的操作 字典中的key值是唯一的 字典为可变数据类型 字典的创建方式 大括号包裹键值对：mydict = {1:’a’ , 2:’b’ } 123&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict&#123;1: 'a', 2: 'b'&#125; 工厂方法创建：mydict = dict(([1,’a’],[2,’b’])) 123&gt;&gt;&gt; mydict = dict(([1,'a'],[2,'b']))&gt;&gt;&gt; mydict&#123;1: 'a', 2: 'b'&#125; 字典内建方法：mydict = dict.fromkeys([1,2],’a’) 1234&gt;&gt;&gt; mydict = dict.fromkeys([1,2],'a')&gt;&gt;&gt; mydict&#123;1: 'a', 2: 'a'&#125;#这样可以批量创建key值，但是缺点也暴露出来无法单独分配value值 访问字典 获得所有key值：dict.keys() 123&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict.keys()dict_keys([1, 2]) 获取所有value值：dict.values() 123&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict.values()dict_values(['a', 'b']) 通过key值获取value： dict[key] ，这个操作类似索引和切片，但实际为字典访问value值，所以不要混淆 注意：在访问一个不存在的key值会引发KeyError的错误 123456789&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict[1]'a'&gt;&gt;&gt; mydict[2]'b'&gt;&gt;&gt; mydict[3]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 3 迭代获取其中key值：for key in dict: 迭代访问到的数据为key值 12345678&gt;&gt;&gt; for key in mydict:... print(key)... print(mydict[key])...1a2b 判断某个key值是否存在字典中 使用 in 还有 not in 判断是否在字典中有对应Key值，返回值为bool类型 123456&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; 1 in mydictTrue&gt;&gt;&gt; 3 in mydictFalse#由于value值是可以重复的，所以判断value是没有意义的 更新字典 通过对应key值访问到value值之后，重新赋值给它则可进行更新 1234&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict[1] = 'c'&gt;&gt;&gt; mydict&#123;1: 'c', 2: 'b'&#125; 删除字典中的值 使用del语句删除对应key值所关联的value值，会把这个键值对删除掉 1234&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; del mydict[1]&gt;&gt;&gt; mydict&#123;2: 'b'&#125; pop(obj) 函数删除字典中的某个值，并将被删除值返回 12345&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict.pop(1)'a'&gt;&gt;&gt; mydict&#123;2: 'b'&#125; 清空字典 dict.clear() 函数会将这个字典重新成为一个新的空字典 1234&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; mydict.clear()&gt;&gt;&gt; mydict&#123;&#125; del语句直接删除字典变量，这也是最粗暴的方式 1234567&gt;&gt;&gt; mydict = &#123;1:'a',2:'b'&#125;&gt;&gt;&gt; del mydict&gt;&gt;&gt; mydictTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'mydict' is not defined#字典被删除之后连变量都不见了 集合 集合：把不同元素组合在一起形成的一个数据集合 集合分为两种：可变集合(set)，不可变集合(frozenset) 集合的内部结构和字典类似，但是不存储value，其中的元素也会进行hash运算，可以称的上是一个没有value的字典 集合中数据元素不能为可变数据对象 12345&gt;&gt;&gt; myset = &#123;[1,2,3]&#125;Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unhashable type: 'list'#可变数据对象不可hash，所以不能成为集合中数据元素 创建集合 可变集合 123456&gt;&gt;&gt; myset = &#123;1,2,3,4,5&#125;#直接通过大括号创建&gt;&gt;&gt; myset = set([1,2,3,1,2,3])&gt;&gt;&gt; myset&#123;1, 2, 3&#125;#通过工厂函数接收一个可迭代对象 不可变集合 123&gt;&gt;&gt; myset = frozenset([1,2,3,1,2,3])&gt;&gt;&gt; mysetfrozenset(&#123;1, 2, 3&#125;) 访问集合 迭代访问集合 12345678&gt;&gt;&gt; myset = &#123;1,2,3&#125;&gt;&gt;&gt; for var in myset:... print(var)...123#集合虽然无序，但是可以通过for循环迭代访问 更新集合 set.add()：更新可hash数据类型到集合中，并维持数据类型 由于集合中的数据元素需要进行hash运算，可变数据类型是不可以进行hash运算的，也就不能传递进来被更新 1234567891011&gt;&gt;&gt; myset = &#123;1,2&#125;&gt;&gt;&gt; myset.add('abc') #更新字符串到集合中&gt;&gt;&gt; myset&#123;1, 2, 'abc'&#125;&gt;&gt;&gt; myset.add((1,2,3)) #更新元组到集合中&gt;&gt;&gt; myset&#123;1, 2, 'abc', (1, 2, 3)&#125;&gt;&gt;&gt; myset.add([1,2,3]) #更新列表到集合中报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unhashable type: 'list' set.update()：如果传入的是一个序列，将被拆分成单个元素，并且去重 12345678910&gt;&gt;&gt; myset = &#123;1,2&#125;&gt;&gt;&gt; myset.update('abc') #更新字符串&gt;&gt;&gt; myset&#123;1, 2, 'b', 'c', 'a'&#125; #字符串被拆开&gt;&gt;&gt; myset.update([1,2,3]) #更新列表&gt;&gt;&gt; myset&#123;1, 2, 3, 'b', 'c', 'a'&#125; #这里列表支持更新是因为存储的数据已经不再是列表，而是列表中的每一个实际数据&gt;&gt;&gt; myset.update((3,4,5)) #更新元组&gt;&gt;&gt; myset&#123;1, 2, 3, 4, 'b', 5, 'c', 'a'&#125; #元组中的每一个数据都被拿出更新到集合中，并且去重 可变集合支持更新操作，不可变集合不支持更新操作 12345678910111213&gt;&gt;&gt; myset = frozenset('abc')&gt;&gt;&gt; mysetfrozenset(&#123;'a', 'b', 'c'&#125;)&gt;&gt;&gt; myset.add()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'frozenset' object has no attribute 'add'#不可变集合不支持add更新&gt;&gt;&gt; myset.update()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'frozenset' object has no attribute 'update'#不可变集合不支持update更新 删除集合中的元素 s.remove(obj)：删除obj元素从集合s中 - 该函数在删除一个不存在的数据时会引发KeyError 12345678&gt;&gt;&gt; myset = &#123;1,2,3&#125;&gt;&gt;&gt; myset.remove(3)&gt;&gt;&gt; myset&#123;1, 2&#125;&gt;&gt;&gt; myset.remove(5)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 5 s.discard(obj) ：如果obj是集合s中的元素，从集合s中删除对象obj 该函数在删除一个不存在的数据时不会报错 12345678&gt;&gt;&gt; myset = &#123;1,2&#125;&gt;&gt;&gt; myset.discard(1)&gt;&gt;&gt; myset&#123;2&#125;&gt;&gt;&gt; myset = &#123;1,2&#125;&gt;&gt;&gt; myset.discard(3)&gt;&gt;&gt; myset&#123;1, 2&#125; del myset：删除这个集合变量 123456&gt;&gt;&gt; myset = &#123;1,2,3&#125;&gt;&gt;&gt; del myset&gt;&gt;&gt; mysetTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'myset' is not defined 集合类型操作符 in 和 not in可以判断某个元素是否在集合中 1234567&gt;&gt;&gt; myset = &#123;1,2&#125;&gt;&gt;&gt; 1 in mysetTrue&gt;&gt;&gt; 3 in mysetFalse&gt;&gt;&gt; 2 not in mysetFalse 子集和超集： a &lt; b：a是否是b的子集a.issubset(b) a的元素b都有 a &gt; b：a是否是b的超集a.issuperset(b) 超集就代表a中的元素囊括了所有b的集合元素 123456&gt;&gt;&gt; a = &#123;1,2&#125;&gt;&gt;&gt; b = &#123;1,2,3,4&#125;&gt;&gt;&gt; a &lt; bTrue&gt;&gt;&gt; a.issubset(b)True 集合的交、并、补操作 联合：在a集合中和b集合去重数据元素，剩下的组合到一起返回一个新的集合 操作符：a | b 函数：a.union(b) 1234&gt;&gt;&gt; a = &#123;1,2,'a','b'&#125;&gt;&gt;&gt; b = &#123;1,3,'a','c'&#125;&gt;&gt;&gt; a | b&#123;1, 2, 3, 'c', 'b', 'a'&#125; 交集：在a集合和b集合中，共同含有的集合成员去掉重复数据，组成到一起返回一个新的集合 操作符：a &amp;b 函数：a.intersection(b) 1234&gt;&gt;&gt; a = &#123;1,2,'a','b'&#125;&gt;&gt;&gt; b = &#123;1,3,'a','c'&#125;&gt;&gt;&gt; a &amp; b&#123;'a', 1&#125; 差补：在a集合中去掉所有与b集合中相同的元素，只在a中保留b中没有的集合成员 操作符：a – b 函数：a.difference(b) 1234&gt;&gt;&gt; a = &#123;1,2,'a','b'&#125;&gt;&gt;&gt; b = &#123;1,3,'a','c'&#125;&gt;&gt;&gt; a - b&#123;2, 'b'&#125; 对称差分：找出两个集合中，只属于集合a或集合b的元素；也就是去掉共有元素后，返回一个新的集合 操作符：a ^ b 函数：a.symmetric_differenc(b) 1234&gt;&gt;&gt; a = &#123;1,2,'a','b'&#125;&gt;&gt;&gt; b = &#123;1,3,'a','c'&#125;&gt;&gt;&gt; a ^ b&#123;2, 3, 'b', 'c'&#125; 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2FA7.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深浅拷贝在Python中，面对列表这种可变数据类型，在赋值的过程中，需要我们注意这么一个地方： 12345678&gt;&gt;&gt; mylist = [1,2,3,4]&gt;&gt;&gt; mylist1 = mylist&gt;&gt;&gt; mylist[0] = 'a'&gt;&gt;&gt; mylist['a',2,3,4]&gt;&gt;&gt; mylist1['a',2,3,4]#普通的赋值操作结束后，两个列表修改其中一个，会影响到另一个，此时并没有真正意义上进行数据拷贝，只是变量的引用 浅拷贝 实现浅拷贝的几种方式： 切片拷贝 copy函数（来自copy模块） 12345678&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist1 = mylist[:] #mylist1切片拷贝自mylist&gt;&gt;&gt; mylist[0] = 'a'&gt;&gt;&gt; mylist['a', 2, 3]&gt;&gt;&gt; mylist1[1, 2, 3]#切片实现浅拷贝，修改其中一个，另一个不会随之更改 123456789&gt;&gt;&gt; import copy&gt;&gt;&gt; mylist = [1,2,3]&gt;&gt;&gt; mylist1 = copy.copy(mylist)&gt;&gt;&gt; mylist[0] = 'a'&gt;&gt;&gt; mylist1[1, 2, 3]&gt;&gt;&gt; mylist['a', 2, 3]#这里在进行浅拷贝之后，两个列表中的值修改不会互相影响 但是浅拷贝也存在一个问题，虽然可以将列表数据进行复制拷贝，但是只能是浅层对象的拷贝： 123456789&gt;&gt;&gt; import copy&gt;&gt;&gt; mylist = [1,2,['a','b']]&gt;&gt;&gt; mylist1 = copy.copy(mylist)&gt;&gt;&gt; mylist[-1][0] = 1 #修改嵌套列表中的第一个数据元素&gt;&gt;&gt; mylist[1, 2, [1, 'b']]&gt;&gt;&gt; mylist1[1, 2, [1, 'b']]#此时浅拷贝无法拷贝深层对象，修改结果互相影响 深拷贝 实现深拷贝的方式： copy模块下的deepcopy函数 123456789&gt;&gt;&gt; import copy&gt;&gt;&gt; mylist = [1,2,['a','b']]&gt;&gt;&gt; mylist1 = copy.deepcopy(mylist)&gt;&gt;&gt; mylist[-1][0] = 1&gt;&gt;&gt; mylist[1, 2, [1, 'b']]&gt;&gt;&gt; mylist1[1, 2, ['a', 'b']]#经过deepcopy函数拷贝后，深层次对象也会被拷贝 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出]]></title>
    <url>%2FA6.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[输出 print 函数直接输出字符串和数值类型 12345&gt;&gt;&gt; print(1)1&gt;&gt;&gt; print('hello world')hello world#无论什么类型，数值，布尔，列表，字典..这些变量都可以直接输出 格式化输出，类似于c语言的 print 1234&gt;&gt;&gt; s= 'hello'&gt;&gt;&gt; x = len(s)&gt;&gt;&gt; print( 'the length of %s is %d' % ( s, x ) )The length of Hello is 5 转义输出类型 转义类型 解释 d,i 十进制 o 八进制 u 十进制 x 十六进制(小写) X 十六进制(小写) e 科学计数法浮点数(小写) E 科学计数法浮点数(大写) f,F 十进制浮点数 C 接收整数(会转换为对应ascii码字符)、 单字符) s 字符串 12345678910111213141516&gt;&gt;&gt; print('%d %i' % (20,-10)) #d,i20 -10&gt;&gt;&gt; print('%o'%-10) #o-12&gt;&gt;&gt; print('%u' % 20) #u20&gt;&gt;&gt; print('%x'%12) #xc&gt;&gt;&gt; print('%e'%2.56) #e2.560000e+00&gt;&gt;&gt; print('%f'%2.56) #f2.560000&gt;&gt;&gt; print('%c'% 65) #CA&gt;&gt;&gt; print('%s'% 'abc') #sabc 输入input Python2： raw_input() input() input 会默认用户输入的是合法的Python表达式 raw_input 会把所有的输入当做字符串进行处理 123456789#python2.x raw_input&gt;&gt;&gt; var = raw_input('pls type a num you want:')pls type a num you want:20&gt;&gt;&gt; var'20'&gt;&gt;&gt; var = raw_input('pls type a num you want:')pls type a num you want:abc&gt;&gt;&gt; var'abc' 12345678910111213141516#python2.x input&gt;&gt;&gt; var = input('pls type a num you want:')pls type a num you want:20&gt;&gt;&gt; var20&gt;&gt;&gt; var = input('pls type a num you want:')pls type a num you want:abcTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;string&gt;", line 1, in &lt;module&gt;NameError: name 'abc' is not defined#2中的input函数会严格检查输入的类型，abc此时没有指明字符串类型，被当成了变量名，所以引发了 NameError&gt;&gt;&gt; var = input('pls type a num you want:')pls type a num you want:'abc' #改变输入值的类型&gt;&gt;&gt; var'abc' Python3： input() input 会把所有的输入当做字符串进行处理 12345678910#python3.x&gt;&gt;&gt; var = input('pls type a num you want:')pls type a num you want:20&gt;&gt;&gt; var'20'&gt;&gt;&gt; var = input('pls type a num you want:')pls type a num you want:abc&gt;&gt;&gt; var'abc'#input保存的均为字符串类型 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[range内建函数]]></title>
    <url>%2FA5.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-range%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[range内建函数在Python中range函数属于内建函数（不需要从三方模块导入），可以更方便的生产一个范围内的数据 语法格式： 1234#python3.x&gt;&gt;&gt; var = range(10)&gt;&gt;&gt; varrange(0, 10) 在Python2版本中，除了 range 函数，还有一个 xrange 函数1234567#python2.x&gt;&gt;&gt; var = range(10)#生成实际列表数据&gt;&gt;&gt; var[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]#生成抽象数据对象&gt;&gt;&gt; var = xrange(10)&gt;&gt;&gt; varxrange(10) Python2：range函数具体生成有关数据，xrange为生成器（只有在真正用到数据的时候，数据才会产生）， 生成器中的数据可以使用 for 循环迭代访问出来12345678#python3.x&gt;&gt;&gt; for var in range(4):... print(var)...0123 Python3：range函数为生成器，产生range类型的数据，这样做的好处是为了节约内存， 删除了xrange range 函数还支持按照一定步长取值，这里以Python3为例：1234567#python3.x&gt;&gt;&gt; for var in range(0,5,2):... print(var)...024 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件分支及循环语句]]></title>
    <url>%2FA4.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E5%8F%8A%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[条件分支及循环语句 if条件语句语法格式：1234567if 条件语句: 执行代码elif 条件语句: 执行代码else: 执行代码#当条件成立则执行对应的代码，条件判断只会进入一个 小例子：1234567891011&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; if a == b:... print('a == b')... elif a &gt; b:... print('a &gt; b')... else:... print('a &lt; b')...a &lt; b#else可有可无，起到收尾工作，其他条件都会进入到else中 在 if 语句中，缩进表示上下关系 while循环语法格式：123&gt;&gt;&gt; while 条件语句: 执行语句#当条件语句为真时，将执行循环内的代码 小例子：12345678910&gt;&gt;&gt; a = 5&gt;&gt;&gt; while a &gt; 0:... print(a)... a = a - 1...54321 for循环语法格式：123&gt;&gt;&gt; for var in secquence: 执行语句#for语句常用来迭代访问一个可迭代对象，如字符串，列表，元祖这样的序列，或者是文件对象等 小例子：1234567&gt;&gt;&gt; mystr = 'abc'&gt;&gt;&gt; for var in mystr:... print(var)...abc 循环else语句在循环正常结束的时候，我们可以使用else语句来进行收尾工作 语法格式：12345678910&gt;&gt;&gt; mystr = 'abc'&gt;&gt;&gt; for var in mystr:... print(var)... else:... print('all done')...abcall done 12345678910111213&gt;&gt;&gt; mylist = [1,2,3,4,5]&gt;&gt;&gt; while mylist:... print(mylist[0])... mylist = mylist[1:]... else:... print('all done')...12345all done 干预循环 break : 终止循环 如果是用在嵌套循环中，break语句将停止执行最深层次的循环，并开始执行下一行代码 continue : 跳出本次循环，进行下一轮循环 12345678910&gt;&gt;&gt; for var in mystr:... if var == 'b':... break... else:... print(var)... else:... print('all done')...a#在结果中，由于我们干预了正常的循环，所以结果不含有else语句中的内容 123456789101112&gt;&gt;&gt; for var in mystr:... if var == 'b':... continue... else:... print(var)... else:... print('all done')...acall done#在结果中，continue语句只是跳过这次循环，并没有导致循环直接结束，所以else语句中的结果依旧出现 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算表达式]]></title>
    <url>%2FA3.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[运算表达式 算数表达式 基本运算符：+ - * / Python2.x : 除法结果只会向复杂数据类型靠拢，两个整数相除，是否除净结果都为整数。 Python3.x : 除法中无论有无复杂数据类型，结果都将精确到浮点数 其他算数的结果类型取决于运算数字之中最复杂的类型 12345#python2.x&gt;&gt;&gt; 5 / 3 #2中两整数做除法，结果还是整数1 #结果为整数&gt;&gt;&gt; 5 / 3.01.6666666666666667 #只有在参与运算的数据类型中含有浮点数，结果才会成为浮点数 12345#python3.x&gt;&gt;&gt; 5 / 31.6666666666666667 #3中两整数做除法，结果会精确到浮点数&gt;&gt;&gt; 5 / 3.01.6666666666666667 特殊运算符： // 向下取整运算(地板除) % 取余运算 ** 幂值运算 123456&gt;&gt;&gt; 5 // 31&gt;&gt;&gt; 5 % 32&gt;&gt;&gt; 5 ** 3125 除此之外，我们还可以使用round函数来控制返回结果的精度 1234&gt;&gt;&gt; round(5 / 3) #可以获取到5/3的四舍五入结果3&gt;&gt;&gt; round(5 / 3, 2) #控制返回结果的精度为21.67 逻辑表达式 表达式 解释 返回值类型 not a a的逻辑非 bool a and b a和b的逻辑与 bool a or b a和b的逻辑或 bool a is b a和b是同一个对象 bool a is not b a和b不是同一个对象 bool 与 : 真真为真， 真假为假， 假假为假或 : 真真为真， 真假为真， 假假为假非 : 真为假，假为真 12345678&gt;&gt;&gt; a = 1&gt;&gt;&gt; not a #a的逻辑非False&gt;&gt;&gt; b = 0&gt;&gt;&gt; a and b #a和b的逻辑与0&gt;&gt;&gt; a or b #a和b的逻辑或1 is逻辑语句判断的是否为同一个对象， 首先需要值相同 其次数据地址相同12345678&gt;&gt;&gt; a1 = [1,2,3,4,5]&gt;&gt;&gt; a2 = [1,2,3,4,5]&gt;&gt;&gt; a1 is a2 #a1和a2值虽相同，但并不是同一个数据对象False&gt;&gt;&gt; id(a1)2298768048584&gt;&gt;&gt; id(a2) #两数据地址并不相同2298768048392 关系表达式 表达式 解释 返回值类型 a == b a,b是否值相等 bool a != b a,b是否值不等 bool a &gt; b a是否大于b bool a &lt; b a是否小于b bool a &gt;= b a是否大于等于b bool a &lt;= b a是否小于等于b bool 1234567891011121314&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a == bFalse&gt;&gt;&gt; a != bTrue&gt;&gt;&gt; a &gt; bFalse&gt;&gt;&gt; a &lt; bTrue&gt;&gt;&gt; a &lt;= bTrue&gt;&gt;&gt; a &gt;= bFalse 位运算 表达式 解释 实际操作 ~a 按位取反 -(a+1) a &lt;&lt; n 左移n位 - a &gt;&gt; n 右移n位 - a &amp; b a和b按位与 11&gt;1 00&gt;0 01&gt;0 a b a和b按位或 11&gt;1 00&gt;0 01&gt;1 a ^ b a和b按位异或 01&gt;1 11&gt;0 00&gt;0 二进制 计算机中真正存储的二进制为补码位运算都是补码在进行运算正数的原码，反码，补码都是其本身 类型 +1 -1 负数求码规则 原码 0000 0001 1000 0001 第一位为符号位 反码 0000 0001 1111 1110 符号位不变，其余各位取反 补码 0000 0001 1111 1111 反码加一 这里举一个小例子 : 123&gt;&gt;&gt; a = 1&gt;&gt;&gt; ~a-2 结果解释： 首先位运算都是补码在进行运算 1的补码为 : 0000 0001 首先按位取反的结果 : 0000 0001 &gt; 1111 1110 1111 1110 为补码，对其求原码 将该补码看作原码，重新求出的补码即可 1111 1110 原码 1000 0001 反码 (最高位为1，为负数求码过程，符号伪不变，其余各位取反) 1000 0010 补码 (反码加一)-此时我们得到的1000 0010 则是-2的原码，所以~a的结果为-2 位运算小例子 实现两个变量值的替换如 a = 1 , b = 2 ; 替换后结果为 a = 2 , b = 1不允许出现第三个变量 1234567891011121314151617#a: 0000 0001 1#b: 0000 0010 2&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a = a | b #按位或#a: 0000 0011 3#b: 0000 0010 2&gt;&gt;&gt; b = a ^ b #按位异或#a: 0000 0011 3#b: 0000 0001 1&gt;&gt;&gt; a = a ^ b #按位异或#a: 0000 0010 2#b: 0000 0001 1&gt;&gt;&gt; a2&gt;&gt;&gt; b1 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量本质]]></title>
    <url>%2FA2.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[Python变量本质 变量不需先定义在使用，我们可以直接给变量名赋值，直接使用1&gt;&gt;&gt; a = 1 #这里我们可以直接给a变量赋值为1，并没有提前对a进行声明 变量可以重复存储不同种数据类型12&gt;&gt;&gt; a = 1&gt;&gt;&gt; a = 'abc' #对a重复复制并不会导致报错 可以同时为多个变量赋值12345&gt;&gt;&gt; a, b = 1, 2&gt;&gt;&gt; a1&gt;&gt;&gt; b2 变量名遵循C语言风格，变量名可以由字母、数字、下划线组成，数字不可以打头，大小写敏感1234567&gt;&gt;&gt; a1 = 1 #Success&gt;&gt;&gt; _a = 1 #Success&gt;&gt;&gt; 1a = 1 #ErrorFile "&lt;stdin&gt;", line 1 1a = 1 ^SyntaxError: invalid syntax 不支持自增、自减123456789101112131415&gt;&gt;&gt; a = 1&gt;&gt;&gt; ++a #这里的++a并不会报错，是因为+号被解释成了正号，正的正一等于1&gt;&gt;&gt; a1 #结果同样可以看出a并没有实现自增&gt;&gt;&gt; --a #与++a同理，此时为负的负一&gt;&gt;&gt; a++ #后++报错File "&lt;stdin&gt;", line 1 a++ ^SyntaxError: invalid syntax&gt;&gt;&gt; a--File "&lt;stdin&gt;", line 1 a -- ^SyntaxError: invalid syntax 变量引用计数 Python中，相同数据的赋值，会共享同一片空间地址，并非占用一个新的地址单元 为了记录当前使用这个地址的变量有多少，引出了引用计数这个概念 我们可以使用del语句对一个数据的引用计数进行减1的操作 当引用计数最后为0时，这个数据占用的内存地址最终释放 我们可以使用sys模块下的getrefcount(value)函数进行变量value引用计数的查看 1234567891011121314&gt;&gt;&gt; a = 1&gt;&gt;&gt; id(a) #可以使用id函数查看当前变量值所处内存单元1951315008&gt;&gt;&gt; b = a&gt;&gt;&gt; id(b)1951315008&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getrefcount(a)127 #当前有127个变量使用1这个值&gt;&gt;&gt; sys.getrefcount(b) #可以看到两个变量的引用计数相同127&gt;&gt;&gt; del b #删除掉b&gt;&gt;&gt; sys.getrefcount(a)126 #1的引用计数减少为126 这样做的好处在于可以节约内存，防止产生多余的内存碎片 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单数据类型]]></title>
    <url>%2FA1.Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基础数据类型 数字整数(int,long)：整数在3版本没有大小长度分别，内存决定整数最大长度浮点数(float)：具有小数点的数，无穷小数会做精度处理布尔(bool)：非空非0为真，0或空为假复数(complex)：复数的标志为虚部以大写 “J” 或小写 “j” 结尾 1234&gt;&gt;&gt; a = 1 #int&gt;&gt;&gt; a = 1.5 #float&gt;&gt;&gt; a = True #bool&gt;&gt;&gt; a = 2+3j #complex 字符串(str)： 表示方式：使用单引号 ‘abc’ ; 双引号 “abc” ; 或者这样 ‘’’abc’’’ , “””abc”””，单个字符也称作字符串 索引：str[index] 使用index选择访问位置，索引从左向右，从0开始，从右向左，从-1开始&lt;font color=#FF4500&gt;index&lt;/font&gt;也是我们经常称呼的下标，下标值不可大于等于字符串最大长度 切片：str[start:stop:[step…]] ，切片可以获取字符串上一定区间中的值 字符串其中的内容不可变，字符串为不可变数据对象123456789101112131415161718192021&gt;&gt;&gt; mystr = '' #创建空字符串&gt;&gt;&gt; mystr = "a" #单个字符同样为字符串&gt;&gt;&gt; mystr = 'abcdefg'&gt;&gt;&gt; mystr[0] #索引值为正时，顺序从左向右取对应位置数据'a'&gt;&gt;&gt; mystr[-1] #索引值为负时，顺序从右边向左取对应位置数据'g'&gt;&gt;&gt; mystr[:] #未给出开始，结束索引；选择整个列表范围内的值'abcdefg'&gt;&gt;&gt; mystr[:2] #切片选择0-2范围内的值，不包含索引为2的值'ab'&gt;&gt;&gt; mystr[-3:] #切片选择从-3到最后位置的值'efg'&gt;&gt;&gt; mystr[0:4:2] #切片选择取索引0-4范围内的值(不包含索引4)，并且步长为2'ac'&gt;&gt;&gt; mystr[::-1] #切片选择整个索引范围内的值，步长为负值时，为逆序'gfedcba'&gt;&gt;&gt; mystr[0] = 1 #当对字符串数据对象进行值修改，报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment 列表(list)： 列表(list)是使用最频繁的数据之一 表示方式：使用中括号，逗号分隔每个数据元素：[ ‘a’, ‘b’ , ‘c’ ] 列表同样可以支持索引和切片操作 列表为可变数据对象，列表中的数据可以被修改 可以创建一个空列表，或者只有一个元素的列表12345678910111213141516171819&gt;&gt;&gt; mylist = [] #创建空列表&gt;&gt;&gt; mylist = [1,2,3,4]&gt;&gt;&gt; mylist[0] #索引值为正时，顺序从左向右取对应位置数据1&gt;&gt;&gt; mylist[-1] #索引值为负时，顺序从右边向左取对应位置数据4&gt;&gt;&gt; mylist[:] #未给出开始，结束索引；选择整个列表范围内的值[1,2,3,4]&gt;&gt;&gt; mylist[:2] #切片选择0-2范围内的值，不包含索引为2的值[1,2]&gt;&gt;&gt; mylist[-3:] #切片选择从-3到最后位置的值[2,3,4]&gt;&gt;&gt; mylist[0:4:2] #切片选择取索引0-4范围内的值(不包含索引4)，并且步长为2[1,3]&gt;&gt;&gt; mylist[::-1] #切片选择整个索引范围内的值，步长为负值时，为逆序[4,3,2,1]&gt;&gt;&gt; mylist[0] = 'a' #修改列表第一个位置上的值为字母'a'&gt;&gt;&gt; mylist['a',2,3,4]#列表为可变数据对象 元组(tuple)： 元组和列表类似，不同之处在于元组内数据不可以被修改 表示方式：使用小括号，逗号分隔每个数据元素：( ‘a’, ‘b’, ‘c’ ) 元组同样索引和切片操作 元组中的数据不可以被修改，元组为不可变数据对象 单纯的创建一个只含有一个元素的元组是会被解释器认为是一个实际数据对象，并不解释成元组 创建只含有一个元素的元组：(1,) 123456789101112131415161718192021222324&gt;&gt;&gt; mytuple = (1,) #正确方式创建只含有一个数据的元组&gt;&gt;&gt; mytuple(1,)#返回值为元组&gt;&gt;&gt; mytuple = (1) #错误方式创建只含有一个数据的元组1#返回值为整型&gt;&gt;&gt; mytuple = (1, 2, 3, 4, 5)&gt;&gt;&gt; mytuple[0]1&gt;&gt;&gt; mytuple[-1] #索引值为负时，顺序从右边向左取对应位置数据4&gt;&gt;&gt; mytuple[:] #未给出开始，结束索引；选择整个列表范围内的值(1, 2, 3, 4, 5)&gt;&gt;&gt; mytuple[:2] #切片选择0-2范围内的值，不包含索引为2的值(1, 2)&gt;&gt;&gt; mytuple[-3:] #切片选择从-3到最后位置的值(3, 4, 5)&gt;&gt;&gt; mytuple[0:4:2] #切片选择取索引0-4范围内的值(不包含索引4)，并且步长为2(1, 3)&gt;&gt;&gt; mytuple[::-1] #切片选择整个索引范围内的值，步长为负值时，为逆序(5, 4, 3, 2, 1)&gt;&gt;&gt; mytuple[0] = 'a' #当对元组数据对象进行值修改，报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment 转载请注明原文地址]]></content>
      <categories>
        <category>1、Python语法基础</category>
      </categories>
      <tags>
        <tag>Python3.x</tag>
        <tag>Python语法基础</tag>
      </tags>
  </entry>
</search>
